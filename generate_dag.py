import json
import requests
from typing import Dict, List, Tuple

def call_model(url: str, messages: List[Dict], generate_params: Dict) -> str:
    """Call the large language model API"""
    params = {
        "messages": messages,
        "params": generate_params
    }
    response = requests.post(
        f"{url}/api/chat",
        json=params,
        timeout=60
    )
    response.raise_for_status()
    return response.json()['data']['text']

def generate_dag_with_llm(model_url: str, task_description: str) -> str:
    """
    Generate DAG using three large model calls
    Args:
        model_url: Model API URL
        task_description: Task description
    Returns:
        Generated DAG text
    """
    generate_params = {
        "do_sample": True,
        "max_new_tokens": 1000,
        'repetition_penalty': 1.1,
    }
    
    # Define prompts
    prompt1 = """Task: {task}

Decompose the entire task into multiple sub-tasks suitable for visualization in a dialogue context. Create a list of nodes where each node represents a distinct sub-task or action related to completing the task through dialogue. Use the following guidelines:

- Node Definition: Use distinct nodes to represent sub-tasks. Nodes must represent the status of assistants rather than users. Nodes MUST be named exactly as "N1", "N2", "N3", "N4", etc. (Do NOT use A, B, C or any other format, and do NOT add any prefixes before N1).

- Advanced Dialogue Operation: Each node should encapsulate the core emotion or function of the fragment related to the task. It should be a label representing nodes of advanced dialogue actions, not just dialogues.

- Sub-task Clarity: Ensure each node clearly defines the sub-task it represents, focusing on specific actions or goals within the task.

- Node List: Present the nodes in a simple list format without establishing connections or dependencies at this stage.

- Mermaid.js Compatibility: Ensure that the node definitions are compatible with Mermaid.js for seamless integration into visual diagrams.

- Keep the number of sub-task nodes concise and manageable (preferably between 5-10 nodes).

Tasks always start with greeting users and asking them what they want. Ensure that each node is clearly defined and distinct. Don't add useless prefixes, just node names and descriptions."""

    prompt2 = """Task: {task}

Sub-Task list: {sub_task_list}

Build upon the previously decomposed sub-tasks and establish dependencies between them. Create a directed acyclic graph (DAG) that accurately captures the logical and sequential relationships among the sub-tasks. Use the following types of dependencies:

1. Task Sequence Dependency: Ensure tasks are executed in the correct order. Represented by a directed edge from the preceding task to the subsequent task.

2. Information Dependency: Indicate that a task requires information or data generated by a preceding task. Represented by a directed edge from the task generating the information to the task that consumes it.

3. Conditional Dependency: Specify that a task can only proceed if certain conditions are met, determined by the outcome of a preceding task. Represented by a directed edge from the preceding task to the conditional task.

- Ensure that the graph remains a directed acyclic graph (DAG) without loops or cyclic paths.

- Flow and Directionality: Maintain a logical progression through the task flow, allowing for branching as necessary to accommodate different task paths.

- Sub-task Relationship: Clearly define the dependencies to ensure that each sub-task is executed in the appropriate context and order.

The diagram should be connected. Don't add useless prefixes, just nodes and edges."""

    prompt3 = """Task: {task}

Initial Sub-Task Graph: {initial_sub_task_graph}

Enhance the previously established sub-task graph by applying constraints to each node. Ensure that all relevant limitations and requirements are explicitly represented. Use the following types of constraints:

1. Content Constraints: Include keyword and topic constraints to ensure specific content is addressed within the dialogue.

2. Logical Constraints: Include conditional and branching constraints to dynamically adjust the dialogue flow based on user responses.

3. Timing Constraints: Include response time and dialogue length constraints to maintain efficiency and enhance user experience.

4. Format Constraints: Include sentence structure and language style constraints to ensure consistent and standardized expression.

- Ensure that the graph remains a directed acyclic graph (DAG) without loops or cyclic paths.

- Constraint Application: Clearly annotate each node with its relevant constraints to guide the dialogue process effectively.

Do not alter the initial sub-task graph structure; only add the corresponding constraints to each node.

Output the enhanced DAG in Mermaid.js format, with each node containing both its original task description and the added constraints."""
    
    # First call: Generate initial task decomposition
    messages1 = [{"role": "system", "content": prompt1.format(task=task_description)},
                {"role": "user", "content": task_description}]
    first_result = call_model(model_url, messages1, generate_params)
    print("\n=== First LLM Call Result ===")
    print(first_result)
    
    # Second call: Generate detailed process based on first result
    messages2 = [{"role": "system", "content": prompt2.format(
                    task=task_description,
                    sub_task_list=first_result)},
                {"role": "user", "content": f"Based on the sub-tasks above, create a DAG structure showing their dependencies."}]
    second_result = call_model(model_url, messages2, generate_params)
    print("\n=== Second LLM Call Result ===")
    print(second_result)
    
    # Third call: Add constraints to each node
    messages3 = [{"role": "system", "content": prompt3.format(
                    task=task_description,
                    initial_sub_task_graph=second_result)},
                {"role": "user", "content": "Add appropriate constraints to each node in the DAG while maintaining the original structure."}]
    dag_text = call_model(model_url, messages3, generate_params)
    print("\n=== Final DAG with Constraints ===")
    print(dag_text)
    
    return dag_text

def save_dag_to_file(dag_text: str, output_file: str = "generated_dag.txt") -> str:
    """
    Save the generated DAG to a file
    Args:
        dag_text: DAG text
        output_file: Output filename
    Returns:
        Path of the saved file
    """
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(dag_text)
    return output_file

# For testing only
if __name__ == "__main__":
    MODEL_URL = "xxxxxxxxxxxxxxxx"
    TEST_TASK = "Understand the job seeker's current employment situation, and then try to obtain their phone number for subsequent contact"
    
    try:
        dag_text = generate_dag_with_llm(MODEL_URL, TEST_TASK)
        output_file = save_dag_to_file(dag_text)
        print(f"\nDAG has been saved to: {output_file}")
    except Exception as e:
        print(f"Error generating DAG: {str(e)}")
        import traceback
        print(traceback.format_exc()) 